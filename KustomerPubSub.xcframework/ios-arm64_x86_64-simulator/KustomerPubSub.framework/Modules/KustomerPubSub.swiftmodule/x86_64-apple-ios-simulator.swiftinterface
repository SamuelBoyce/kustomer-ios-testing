// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -module-name KustomerPubSub
import CommonCrypto
import Foundation
import Swift
public protocol KustomerPubNubV3Presence {
  var channel: Swift.String { get }
  var occupancy: Swift.Int { get set }
  var occupants: [Swift.String] { get set }
  var occupantsState: [Swift.String : KustomerPubSub.JSONCodable] { get set }
  init(from other: KustomerPubSub.KustomerPubNubV3Presence) throws
}
extension KustomerPubNubV3Presence {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3Presence
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3Presence
}
extension Dictionary where Key == Swift.String, Value == KustomerPubSub.KustomerPubNubV3Presence {
  public var totalChannels: Swift.Int {
    get
  }
  public var totalOccupancy: Swift.Int {
    get
  }
}
public struct KustomerPubNubV3PresenceBase : KustomerPubSub.KustomerPubNubV3Presence, Swift.Hashable {
  public let channel: Swift.String
  public var occupancy: Swift.Int
  public var occupants: [Swift.String]
  public var occupantsState: [Swift.String : KustomerPubSub.JSONCodable] {
    get
    set
  }
  public init(channel: Swift.String, occupancy: Swift.Int, occupants: [Swift.String], occupantsState concreteOccupantsState: [Swift.String : KustomerPubSub.JSONCodable])
  public init(from other: KustomerPubSub.KustomerPubNubV3Presence) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3PresenceBase, b: KustomerPubSub.KustomerPubNubV3PresenceBase) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum KustomerPubNubV3PresenceChangeAction : Swift.Hashable {
  case join(uuids: [Swift.String])
  case leave(uuids: [Swift.String])
  case timeout(uuids: [Swift.String])
  case stateChange(uuid: Swift.String, state: KustomerPubSub.JSONCodable)
  public static func == (lhs: KustomerPubSub.KustomerPubNubV3PresenceChangeAction, rhs: KustomerPubSub.KustomerPubNubV3PresenceChangeAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Array where Element == KustomerPubSub.KustomerPubNubV3PresenceChangeAction {
  public func join(contains uuid: Swift.String) -> Swift.Bool
  public func leave(contains uuid: Swift.String) -> Swift.Bool
  public func timeout(contains uuid: Swift.String) -> Swift.Bool
}
public protocol KustomerPubNubV3PresenceChange {
  var actions: [KustomerPubSub.KustomerPubNubV3PresenceChangeAction] { get }
  var occupancy: Swift.Int { get }
  var timetoken: KustomerPubSub.KUSPNTtoken { get }
  var refreshHereNow: Swift.Bool { get }
  var channel: Swift.String { get }
  var subscription: Swift.String? { get }
  var published: KustomerPubSub.KUSPNTtoken? { get }
  var metadata: KustomerPubSub.JSONCodable? { get }
  init(from other: KustomerPubSub.KustomerPubNubV3PresenceChange) throws
}
extension KustomerPubNubV3PresenceChange {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3PresenceChange
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3PresenceChange
}
public struct KustomerPubNubV3PresenceChangeBase : KustomerPubSub.KustomerPubNubV3PresenceChange, Swift.Hashable {
  public var actions: [KustomerPubSub.KustomerPubNubV3PresenceChangeAction]
  public var occupancy: Swift.Int
  public var timetoken: KustomerPubSub.KUSPNTtoken
  public var refreshHereNow: Swift.Bool
  public var channel: Swift.String
  public var subscription: Swift.String?
  public var published: KustomerPubSub.KUSPNTtoken?
  public var metadata: KustomerPubSub.JSONCodable? {
    get
  }
  public init(from other: KustomerPubSub.KustomerPubNubV3PresenceChange) throws
  public init(actions: [KustomerPubSub.KustomerPubNubV3PresenceChangeAction], occupancy: Swift.Int, timetoken: KustomerPubSub.KUSPNTtoken, refreshHereNow: Swift.Bool, channel: Swift.String, subscription: Swift.String? = nil, published: KustomerPubSub.KUSPNTtoken? = nil, metadata: KustomerPubSub.JSONCodable? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3PresenceChangeBase, b: KustomerPubSub.KustomerPubNubV3PresenceChangeBase) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct KustomerPubNubV3Error : Swift.Error {
  public let reason: KustomerPubSub.KustomerPubNubV3Error.Reason
  public let details: [Swift.String]
  public let underlying: Swift.Error?
  public let affected: [KustomerPubSub.KustomerPubNubV3Error.AffectedValue]
  public let router: KustomerPubSub.HTTPRouter?
  public let domain: Swift.String
  public var subdomain: KustomerPubSub.KustomerPubNubV3Error.Domain {
    get
  }
  public enum AffectedValue : Swift.Hashable {
    case uuid(Foundation.UUID)
    case string(Swift.String)
    case data(Foundation.Data)
    case request(Foundation.URLRequest)
    case response(Foundation.HTTPURLResponse)
    case json(KustomerPubSub.AnyJSON)
    case subscribe(KustomerPubSub.SubscribeCursor)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: KustomerPubSub.KustomerPubNubV3Error.AffectedValue, b: KustomerPubSub.KustomerPubNubV3Error.AffectedValue) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Domain : Swift.Int, Swift.Error, Swift.Hashable, Swift.Codable, Foundation.LocalizedError {
    case urlCreation
    case jsonCodability
    case requestProcessing
    case crypto
    case requestTransmission
    case responseReceiving
    case responseProcessing
    case endpointResponse
    case serviceNotEnabled
    case uncategorized
    case cancellation
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Reason : Swift.Int, Swift.Equatable, Swift.Hashable, Swift.Codable {
    case missingRequiredParameter
    case invalidEndpointType
    case missingPublishKey
    case missingSubscribeKey
    case missingPublishAndSubscribeKey
    case jsonStringEncodingFailure
    case jsonStringDecodingFailure
    case jsonDataEncodingFailure
    case jsonDataDecodingFailure
    case missingCryptoKey
    case requestMutatorFailure
    case requestRetryFailed
    case timedOut
    case nameResolutionFailure
    case invalidURL
    case connectionFailure
    case connectionOverDataFailure
    case connectionLost
    case secureConnectionFailure
    case certificateTrustFailure
    case sessionDeinitialized
    case sessionInvalidated
    case clientCancelled
    case longPollingRestart
    case badServerResponse
    case responseDecodingFailure
    case dataLengthExceedsMaximum
    case missingCriticalResponseData
    case unrecognizedStatusCode
    case malformedResponseBody
    case invalidArguments
    case invalidCharacter
    case invalidDevicePushToken
    case invalidSubscribeKey
    case invalidPublishKey
    case maxChannelGroupCountExceeded
    case couldNotParseRequest
    case requestContainedInvalidJSON
    case messageCountExceededMaximum
    case messageTooLong
    case invalidUUID
    case nothingToDelete
    case failedToPublish
    case pushNotEnabled
    case messageHistoryNotEnabled
    case messageDeletionNotEnabled
    case multiplexingNotEnabled
    case unknown
    case badRequest
    case unauthorized
    case forbidden
    case resourceNotFound
    case conflict
    case preconditionFailed
    case requestURITooLong
    case tooManyRequests
    case unsupportedType
    case malformedFilterExpression
    case internalServiceError
    case serviceUnavailable
    public var domain: KustomerPubSub.KustomerPubNubV3Error.Domain {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension KustomerPubNubV3Error : Swift.Hashable {
  public static func == (lhs: KustomerPubSub.KustomerPubNubV3Error, rhs: KustomerPubSub.KustomerPubNubV3Error) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Optional where Wrapped == KustomerPubSub.KustomerPubNubV3Error {
  public static func == (lhs: Swift.Optional<Wrapped>, rhs: KustomerPubSub.KustomerPubNubV3Error.Reason?) -> Swift.Bool
  public static func != (lhs: Swift.Optional<Wrapped>, rhs: KustomerPubSub.KustomerPubNubV3Error.Reason?) -> Swift.Bool
}
extension Optional where Wrapped == KustomerPubSub.KustomerPubNubV3Error.Reason {
  public static func == (lhs: Swift.Optional<Wrapped>, rhs: KustomerPubSub.KustomerPubNubV3Error?) -> Swift.Bool
  public static func != (lhs: Swift.Optional<Wrapped>, rhs: KustomerPubSub.KustomerPubNubV3Error?) -> Swift.Bool
}
extension KustomerPubNubV3Error {
  public var urlError: Foundation.URLError? {
    get
  }
}
public struct RequestIdOperator : KustomerPubSub.RequestOperator {
  public let requestID: Swift.String
  public func mutate(_ urlRequest: Foundation.URLRequest, for _: KustomerPubSub.SessionReplaceable, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public struct SubscriptionState {
  public var connectionState: KustomerPubSub.KUSPubSubConnectionStatus
  public var channels: [Swift.String : KustomerPubSub.KustomerPubNubV3Channel]
  public var groups: [Swift.String : KustomerPubSub.KustomerPubNubV3Channel]
  public var subscribedChannels: [Swift.String] {
    get
  }
  public var subscribedGroups: [Swift.String] {
    get
  }
  public var totalSubscribedCount: Swift.Int {
    get
  }
}
public struct KustomerPubNubV3Channel : Swift.Hashable {
  public let id: Swift.String
  public let presenceId: Swift.String
  public var isPresenceSubscribed: Swift.Bool
  public init(id: Swift.String, withPresence: Swift.Bool = false)
  public init(channel: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3Channel, b: KustomerPubSub.KustomerPubNubV3Channel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerPubNubV3Channel : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Dictionary where Key == Swift.String, Value == KustomerPubSub.KustomerPubNubV3Channel {
  public mutating func insert(_ channel: Value) -> Swift.Bool
  public mutating func unsubscribePresence(_ id: Swift.String) -> Value?
}
public protocol JSONCodable : Swift.Decodable, Swift.Encodable {
  var codableValue: KustomerPubSub.AnyJSON { get }
  var rawValue: Any { get }
}
extension JSONCodable {
  public var rawValue: Any {
    get
  }
  public var codableValue: KustomerPubSub.AnyJSON {
    get
  }
  public var isScalar: Swift.Bool {
    get
  }
  public var jsonStringifyResult: Swift.Result<Swift.String, Swift.Error> {
    get
  }
  public var jsonStringify: Swift.String? {
    get
  }
  public var jsonDataResult: Swift.Result<Foundation.Data, Swift.Error> {
    get
  }
  public var jsonData: Foundation.Data? {
    get
  }
  public var isNil: Swift.Bool {
    get
  }
  public var stringOptional: Swift.String? {
    get
  }
  public var intOptional: Swift.Int? {
    get
  }
  public var doubleOptional: Swift.Double? {
    get
  }
  public var boolOptional: Swift.Bool? {
    get
  }
  public var dateOptional: Foundation.Date? {
    get
  }
  public var dataOptional: Foundation.Data? {
    get
  }
}
extension Array : KustomerPubSub.JSONCodable where Element : KustomerPubSub.JSONCodable {
}
extension Dictionary : KustomerPubSub.JSONCodable where Key == Swift.String, Value : KustomerPubSub.JSONCodable {
}
extension AnyJSON : KustomerPubSub.JSONCodable {
  public var codableValue: KustomerPubSub.AnyJSON {
    get
  }
  public var rawValue: Any {
    get
  }
}
public protocol JSONCodableScalar : KustomerPubSub.JSONCodable {
  var scalarValue: KustomerPubSub.JSONCodableScalarType { get }
}
extension JSONCodableScalar {
  public var codableValue: KustomerPubSub.AnyJSON {
    get
  }
  public var rawValue: Any {
    get
  }
}
extension String : KustomerPubSub.JSONCodableScalar {
  public var scalarValue: KustomerPubSub.JSONCodableScalarType {
    get
  }
}
extension Int : KustomerPubSub.JSONCodableScalar {
  public var scalarValue: KustomerPubSub.JSONCodableScalarType {
    get
  }
}
extension Double : KustomerPubSub.JSONCodableScalar {
  public var scalarValue: KustomerPubSub.JSONCodableScalarType {
    get
  }
}
extension Bool : KustomerPubSub.JSONCodableScalar {
  public var scalarValue: KustomerPubSub.JSONCodableScalarType {
    get
  }
}
extension Date : KustomerPubSub.JSONCodableScalar {
  public var scalarValue: KustomerPubSub.JSONCodableScalarType {
    get
  }
}
extension JSONCodableScalarType : KustomerPubSub.JSONCodableScalar {
  public var scalarValue: KustomerPubSub.JSONCodableScalarType {
    get
  }
}
public struct JSONCodableScalarType : Swift.Codable, Swift.Hashable {
  public init(stringValue: Swift.String?)
  public init(intValue: Swift.Int)
  public init(boolValue: Swift.Bool)
  public init(doubleValue: Swift.Double)
  public init(dateValue: Foundation.Date)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.JSONCodableScalarType, b: KustomerPubSub.JSONCodableScalarType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Crypto : Swift.Hashable {
  public let key: Foundation.Data?
  public let cipher: KustomerPubSub.Crypto.Cipher
  public let defaultStringEncoding: Swift.String.Encoding
  public init?(key: Swift.String, cipher: KustomerPubSub.Crypto.Cipher = .aes, encoding: Swift.String.Encoding = .utf8)
  public init(key data: Foundation.Data, cipher: KustomerPubSub.Crypto.Cipher = .aes, encoding: Swift.String.Encoding = .utf8)
  public enum Cipher : Swift.RawRepresentable, Swift.Hashable {
    case aes
    public init?(rawValue: CommonCrypto.CCAlgorithm)
    public var rawValue: CommonCrypto.CCAlgorithm {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public var keySizeRange: Swift.ClosedRange<Swift.Int> {
      get
    }
    public func validate(keySize: Swift.Int) -> KustomerPubSub.CryptoError?
    public typealias RawValue = CommonCrypto.CCAlgorithm
  }
  public struct SHA256 {
    public static func hash(data: Foundation.Data) -> Foundation.Data?
  }
  public func encrypt(plaintext stringIn: Swift.String, encoding override: Swift.String.Encoding? = nil) -> Swift.Result<Swift.String, Swift.Error>
  public func encrypt(encoded dataIn: Foundation.Data, dataMovedOut _: Swift.Int = 0) -> Swift.Result<Foundation.Data, Swift.Error>
  public func decrypt(base64Encoded stringIn: Swift.String, encoding override: Swift.String.Encoding? = nil, dataMovedOut _: Swift.Int = 0) -> Swift.Result<Swift.String, Swift.Error>
  public func decrypt(encrypted dataIn: Foundation.Data, dataMovedOut _: Swift.Int = 0) -> Swift.Result<Foundation.Data, Swift.Error>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.Crypto, b: KustomerPubSub.Crypto) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CryptoError : CommonCrypto.CCCryptorStatus, Swift.Error, Foundation.LocalizedError {
  case bufferTooSmall
  case alignmentError
  case decodeError
  case illegalParameter
  case memoryFailure
  case overflow
  case rngFailure
  case unspecifiedError
  case callSequenceError
  case keySizeError
  case invalidKey
  case unimplemented
  case unknown
  public init?(rawValue: CommonCrypto.CCCryptorStatus)
  public typealias RawValue = CommonCrypto.CCCryptorStatus
  public var rawValue: CommonCrypto.CCCryptorStatus {
    get
  }
}
public protocol LogWriter {
  var executor: KustomerPubSub.LogExecutable { get }
  var prefix: KustomerPubSub.LogPrefix { get }
  func send(message: Swift.String)
}
public protocol LogExecutable {
  func execute(log job: @escaping () -> Swift.Void)
}
public enum LogExecutionType : KustomerPubSub.LogExecutable {
  case sync(lock: Foundation.NSLocking)
  case async(queue: Dispatch.DispatchQueue)
  public func execute(log job: @escaping () -> Swift.Void)
}
public struct ConsoleLogWriter : KustomerPubSub.LogWriter {
  public var sendToNSLog: Swift.Bool
  public var executor: KustomerPubSub.LogExecutable
  public var prefix: KustomerPubSub.LogPrefix
  public init(sendToNSLog: Swift.Bool = false, prefix: KustomerPubSub.LogPrefix = .all, executor: KustomerPubSub.LogExecutionType = .sync(lock: NSRecursiveLock()))
  public func send(message: Swift.String)
}
open class FileLogWriter : KustomerPubSub.LogWriter {
  public var executor: KustomerPubSub.LogExecutable
  public var prefix: KustomerPubSub.LogPrefix
  public var maxFileSize: Swift.Int64
  public var maxLogFiles: Swift.Int
  public var directoryURL: Foundation.URL
  public var currentFile: Foundation.URL?
  required public init(logDirectory: Foundation.URL, executor: KustomerPubSub.LogExecutionType = .sync(lock: NSRecursiveLock()), prefix: KustomerPubSub.LogPrefix = .all)
  convenience public init(inside domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, at directory: Foundation.FileManager.SearchPathDirectory = .cachesDirectory, with name: Swift.String = "com.kustomer.sdk.logs.pubnub", executor: KustomerPubSub.LogExecutionType = .sync(lock: NSRecursiveLock()), prefix: KustomerPubSub.LogPrefix = .all)
  public func send(message: Swift.String)
  public func createOrUpdateFile(with contents: Swift.String) -> Foundation.URL?
  public func update(_ file: Foundation.URL, message: Swift.String)
  public func delete(_ file: Foundation.URL)
  @objc deinit
}
extension Thread {
  public static var currentName: Swift.String {
    get
  }
}
public enum KUSPubSubConnectionStatus : Swift.String {
  case connecting
  case connected
  case reconnecting
  case disconnected
  case disconnectedUnexpectedly
  public var isActive: Swift.Bool {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KustomerPubNubV3FCMPayload : Swift.Codable {
  public let payload: KustomerPubSub.JSONCodable?
  public let notification: KustomerPubSub.FCMNotificationPayload?
  public let android: KustomerPubSub.FCMAndroidPayload?
  public let webpush: KustomerPubSub.FCMWebpushConfig?
  public let apns: KustomerPubSub.FCMApnsConfig?
  public let options: KustomerPubSub.FCMOptionsPayload?
  public let target: KustomerPubSub.FCMTarget?
  public init(payload: KustomerPubSub.JSONCodable?, target: KustomerPubSub.FCMTarget?, notification: KustomerPubSub.FCMNotificationPayload? = nil, android: KustomerPubSub.FCMAndroidPayload? = nil, webpush: KustomerPubSub.FCMWebpushConfig? = nil, apns: KustomerPubSub.FCMApnsConfig? = nil, options: KustomerPubSub.FCMOptionsPayload? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum FCMTarget : Swift.Codable, Swift.Hashable {
  case token(Swift.String)
  case topic(Swift.String)
  case condition(Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMTarget, b: KustomerPubSub.FCMTarget) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FCMNotificationPayload : Swift.Codable, Swift.Hashable {
  public let title: Swift.String?
  public let body: Swift.String?
  public let image: Swift.String?
  public init(title: Swift.String? = nil, body: Swift.String? = nil, image: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMNotificationPayload, b: KustomerPubSub.FCMNotificationPayload) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct FCMOptionsPayload : Swift.Codable, Swift.Hashable {
  public let analyticsLabel: Swift.String?
  public init(analyticsLabel: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMOptionsPayload, b: KustomerPubSub.FCMOptionsPayload) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct FCMApnsConfig : Swift.Codable, Swift.Hashable {
  public let headers: [Swift.String : Swift.String]?
  public let payload: KustomerPubSub.APSPayload?
  public let options: KustomerPubSub.FCMApnsFcmOptions?
  public init(headers: [Swift.String : Swift.String]? = nil, payload: KustomerPubSub.APSPayload? = nil, options: KustomerPubSub.FCMApnsFcmOptions? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMApnsConfig, b: KustomerPubSub.FCMApnsConfig) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FCMApnsFcmOptions : Swift.Codable, Swift.Hashable {
  public let analyticsLabel: Swift.String?
  public let image: Swift.String?
  public init(analyticsLabel: Swift.String? = nil, image: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMApnsFcmOptions, b: KustomerPubSub.FCMApnsFcmOptions) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum PNKeyRequirement : Swift.String {
  case none
  case publish
  case subscribe
  case publishAndSubscribe
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum PAMVersionRequirement {
  case none
  case version2
  case version3
  public static func == (a: KustomerPubSub.PAMVersionRequirement, b: KustomerPubSub.PAMVersionRequirement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KustomerPubNubV3Message {
  var payload: KustomerPubSub.JSONCodable { get set }
  var actions: [KustomerPubSub.KustomerPubNubV3MessageAction] { get set }
  var publisher: Swift.String? { get set }
  var channel: Swift.String { get }
  var subscription: Swift.String? { get }
  var published: KustomerPubSub.KUSPNTtoken { get set }
  var metadata: KustomerPubSub.JSONCodable? { get set }
  init(from other: KustomerPubSub.KustomerPubNubV3Message) throws
}
extension KustomerPubNubV3Message {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3Message
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3Message
}
public struct KustomerPubNubV3MessageBase : KustomerPubSub.KustomerPubNubV3Message, Swift.Codable, Swift.Hashable {
  public var publisher: Swift.String?
  public var channel: Swift.String
  public var subscription: Swift.String?
  public var published: KustomerPubSub.KUSPNTtoken
  public var payload: KustomerPubSub.JSONCodable {
    get
    set
  }
  public var actions: [KustomerPubSub.KustomerPubNubV3MessageAction] {
    get
    set(newValue)
  }
  public var metadata: KustomerPubSub.JSONCodable? {
    get
    set
  }
  public init(from other: KustomerPubSub.KustomerPubNubV3Message) throws
  public init(payload: KustomerPubSub.AnyJSON, actions: [KustomerPubSub.KustomerPubNubV3MessageActionBase], publisher: Swift.String?, channel: Swift.String, subscription: Swift.String?, published: KustomerPubSub.KUSPNTtoken, metadata: KustomerPubSub.AnyJSON?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3MessageBase, b: KustomerPubSub.KustomerPubNubV3MessageBase) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol KustomerPubNubV3ChannelMetadata {
  var metadataId: Swift.String { get }
  var name: Swift.String { get set }
  var channelDescription: Swift.String? { get set }
  var updated: Foundation.Date? { get set }
  var eTag: Swift.String? { get set }
  var custom: [Swift.String : KustomerPubSub.JSONCodableScalar]? { get set }
  init(from other: KustomerPubSub.KustomerPubNubV3ChannelMetadata) throws
}
extension KustomerPubNubV3ChannelMetadata {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3ChannelMetadata
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3ChannelMetadata
}
public struct KustomerPubNubV3ChannelMetadataBase : KustomerPubSub.KustomerPubNubV3ChannelMetadata, Swift.Hashable {
  public let metadataId: Swift.String
  public var name: Swift.String
  public var channelDescription: Swift.String?
  public var updated: Foundation.Date?
  public var eTag: Swift.String?
  public var custom: [Swift.String : KustomerPubSub.JSONCodableScalar]? {
    get
    set
  }
  public init(metadataId: Swift.String = UUID().uuidString, name: Swift.String, channelDescription: Swift.String? = nil, custom concreteCustom: [Swift.String : KustomerPubSub.JSONCodableScalar]? = nil, updated: Foundation.Date? = nil, eTag: Swift.String? = nil)
  public init(from other: KustomerPubSub.KustomerPubNubV3ChannelMetadata) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3ChannelMetadataBase, b: KustomerPubSub.KustomerPubNubV3ChannelMetadataBase) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerPubNubV3ChannelMetadataBase : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol EventStreamReceiver {
  var uuid: Foundation.UUID { get }
  var queue: Dispatch.DispatchQueue { get }
}
extension EventStreamReceiver {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol Cancellable {
  var isCancelled: Swift.Bool { get }
  func cancel()
}
public protocol EventStreamEmitter : AnyObject {
  associatedtype ListenerType : KustomerPubSub.Cancellable
  var listeners: [Self.ListenerType] { get }
  func add(_ listener: Self.ListenerType)
  func remove(_ listener: Self.ListenerType)
  func notify(listeners closure: (Self.ListenerType) -> Swift.Void)
}
extension EventStreamEmitter {
  public func remove(_ listener: Self.ListenerType)
}
public class KUSListenerToken : KustomerPubSub.Cancellable {
  public var isCancelled: Swift.Bool {
    get
  }
  final public let tokenId: Foundation.UUID
  public init(cancellationClosure: @escaping () -> Swift.Void)
  @objc deinit
  public func cancel()
}
extension KUSListenerToken : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol KustomerPubNubV3BoundedPage {
  var start: KustomerPubSub.KUSPNTtoken? { get }
  var end: KustomerPubSub.KUSPNTtoken? { get }
  var limit: Swift.Int? { get }
  init(from other: KustomerPubSub.KustomerPubNubV3BoundedPage) throws
}
extension KustomerPubNubV3BoundedPage {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3BoundedPage
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3BoundedPage
}
public struct KustomerPubNubV3BoundedPageBase : KustomerPubSub.KustomerPubNubV3BoundedPage, Swift.Codable, Swift.Hashable {
  public let start: KustomerPubSub.KUSPNTtoken?
  public let end: KustomerPubSub.KUSPNTtoken?
  public let limit: Swift.Int?
  public init?(start: KustomerPubSub.KUSPNTtoken? = nil, end: KustomerPubSub.KUSPNTtoken? = nil, limit: Swift.Int? = nil)
  public init(from other: KustomerPubSub.KustomerPubNubV3BoundedPage) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3BoundedPageBase, b: KustomerPubSub.KustomerPubNubV3BoundedPageBase) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol KustomerPubNubV3HashedPage {
  var start: Swift.String? { get }
  var end: Swift.String? { get }
  var totalCount: Swift.Int? { get }
  init(from other: KustomerPubSub.KustomerPubNubV3HashedPage) throws
}
extension KustomerPubNubV3HashedPage {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3HashedPage
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3HashedPage
}
public struct KustomerPubNubV3HashedPageBase : KustomerPubSub.KustomerPubNubV3HashedPage, Swift.Codable, Swift.Hashable {
  public var start: Swift.String?
  public var end: Swift.String?
  public var totalCount: Swift.Int?
  public init(start: Swift.String? = nil, end: Swift.String? = nil, totalCount: Swift.Int? = nil)
  public init(from other: KustomerPubSub.KustomerPubNubV3HashedPage) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3HashedPageBase, b: KustomerPubSub.KustomerPubNubV3HashedPageBase) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension URL {
  public func appending(queryItems: [Foundation.URLQueryItem]) -> Foundation.URL?
  public var sizeOf: Swift.Int {
    get
  }
}
public protocol URLSessionReplaceable {
  init(configuration: Foundation.URLSessionConfiguration, delegate: Foundation.URLSessionDelegate?, delegateQueue: Foundation.OperationQueue?)
  var sessionDescription: Swift.String? { get set }
  var delegateQueue: Foundation.OperationQueue { get }
  var configuration: Foundation.URLSessionConfiguration { get }
  func dataTask(with request: Foundation.URLRequest) -> Foundation.URLSessionDataTask
  func invalidateAndCancel()
}
extension URLSession : KustomerPubSub.URLSessionReplaceable {
}
public protocol SessionReplaceable {
  var sessionID: Foundation.UUID { get }
  var session: KustomerPubSub.URLSessionReplaceable { get }
  var sessionQueue: Dispatch.DispatchQueue { get }
  var defaultRequestOperator: KustomerPubSub.RequestOperator? { get set }
  var sessionStream: KustomerPubSub.SessionStream? { get set }
  func usingDefault(requestOperator: KustomerPubSub.RequestOperator?) -> Self
  func request(with router: KustomerPubSub.HTTPRouter, requestOperator: KustomerPubSub.RequestOperator?) -> KustomerPubSub.RequestReplaceable
  func invalidateAndCancel()
}
public protocol RequestReplaceable : AnyObject {
  var sessionID: Foundation.UUID { get }
  var requestID: Foundation.UUID { get }
  var router: KustomerPubSub.HTTPRouter { get }
  var requestQueue: Dispatch.DispatchQueue { get }
  var requestOperator: KustomerPubSub.RequestOperator? { get }
  var urlRequest: Foundation.URLRequest? { get }
  var urlResponse: Foundation.HTTPURLResponse? { get }
  func didCreate(_ urlRequest: Foundation.URLRequest)
  func didFailToCreateURLRequest(with error: Swift.Error)
  func didCreate(_ task: Foundation.URLSessionTask)
  func didMutate(_ initialRequest: Foundation.URLRequest, to mutatedRequest: Foundation.URLRequest)
  func didFailToMutate(_ urlRequest: Foundation.URLRequest, with mutatorError: Swift.Error)
  func didReceive(data: Foundation.Data)
  func didComplete(_ task: Foundation.URLSessionTask)
  func didComplete(_ task: Foundation.URLSessionTask, with error: Swift.Error)
  var retryCount: Swift.Int { get }
  var isCancelled: Swift.Bool { get }
  func prepareForRetry()
  @discardableResult
  func cancel(_ error: Swift.Error) -> Self
  func validate() -> Self
  func response<D>(on: Dispatch.DispatchQueue, decoder: D, completion: @escaping (Swift.Result<KustomerPubSub.EndpointResponse<D.Payload>, Swift.Error>) -> Swift.Void) where D : KustomerPubSub.ResponseDecoder
}
public protocol RouterConfiguration {
  var publishKey: Swift.String? { get }
  var subscribeKey: Swift.String { get }
  var uuid: Swift.String { get }
  var useSecureConnections: Swift.Bool { get }
  var origin: Swift.String { get }
  var authKey: Swift.String? { get }
  var cipherKey: KustomerPubSub.Crypto? { get }
  var useRequestId: Swift.Bool { get }
}
extension RouterConfiguration {
  public var urlScheme: Swift.String {
    get
  }
  public var subscribeKeyExists: Swift.Bool {
    get
  }
  public var publishKeyExists: Swift.Bool {
    get
  }
}
extension KustomerPubNubV3Configuration : KustomerPubSub.RouterConfiguration {
}
public enum HTTPMethod : Swift.String {
  case connect
  case delete
  case get
  case head
  case options
  case patch
  case post
  case put
  case trace
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KustomerPubNubV3Service : Swift.String {
  case channelGroup
  case history
  case messageActions
  case objects
  case presence
  case publish
  case push
  case subscribe
  case time
  case unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol HTTPRouter : KustomerPubSub.URLRequestConvertible, KustomerPubSub.Validated, Swift.CustomStringConvertible {
  var service: KustomerPubSub.KustomerPubNubV3Service { get }
  var category: Swift.String { get }
  var configuration: KustomerPubSub.RouterConfiguration { get }
  var method: KustomerPubSub.HTTPMethod { get }
  var path: Swift.Result<Swift.String, Swift.Error> { get }
  var queryItems: Swift.Result<[Foundation.URLQueryItem], Swift.Error> { get }
  var additionalHeaders: [Swift.String : Swift.String] { get }
  var body: Swift.Result<Foundation.Data?, Swift.Error> { get }
  var keysRequired: KustomerPubSub.PNKeyRequirement { get }
  var pamVersion: KustomerPubSub.PAMVersionRequirement { get }
  func decodeError(request: Foundation.URLRequest, response: Foundation.HTTPURLResponse, for data: Foundation.Data) -> KustomerPubSub.KustomerPubNubV3Error?
}
extension HTTPRouter {
  public var method: KustomerPubSub.HTTPMethod {
    get
  }
  public var additionalHeaders: [Swift.String : Swift.String] {
    get
  }
  public var body: Swift.Result<Foundation.Data?, Swift.Error> {
    get
  }
  public var keysRequired: KustomerPubSub.PNKeyRequirement {
    get
  }
  public var pamVersion: KustomerPubSub.PAMVersionRequirement {
    get
  }
  public func decodeError(request: Foundation.URLRequest, response: Foundation.HTTPURLResponse, for data: Foundation.Data) -> KustomerPubSub.KustomerPubNubV3Error?
  public var validationError: Swift.Error? {
    get
  }
  public var keyValidationErrorReason: KustomerPubSub.KustomerPubNubV3Error.Reason? {
    get
  }
}
extension HTTPRouter {
  public var asURL: Swift.Result<Foundation.URL, Swift.Error> {
    get
  }
  public var asURLRequest: Swift.Result<Foundation.URLRequest, Swift.Error> {
    get
  }
}
extension HTTPRouter {
  public var description: Swift.String {
    get
  }
}
public struct LogPrefix : Swift.OptionSet, Swift.Equatable, Swift.Hashable {
  public let rawValue: Swift.UInt32
  public static let none: KustomerPubSub.LogPrefix
  public static let level: KustomerPubSub.LogPrefix
  public static let date: KustomerPubSub.LogPrefix
  public static let queue: KustomerPubSub.LogPrefix
  public static let thread: KustomerPubSub.LogPrefix
  public static let file: KustomerPubSub.LogPrefix
  public static let function: KustomerPubSub.LogPrefix
  public static let line: KustomerPubSub.LogPrefix
  public static let all: KustomerPubSub.LogPrefix
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = KustomerPubSub.LogPrefix
  public typealias Element = KustomerPubSub.LogPrefix
  public typealias RawValue = Swift.UInt32
}
public struct LogType : Swift.OptionSet, Swift.Equatable, Swift.Hashable {
  public let rawValue: Swift.UInt32
  public static let none: KustomerPubSub.LogType
  public static let debug: KustomerPubSub.LogType
  public static let info: KustomerPubSub.LogType
  public static let event: KustomerPubSub.LogType
  public static let warn: KustomerPubSub.LogType
  public static let error: KustomerPubSub.LogType
  public static let log: KustomerPubSub.LogType
  public static let all: KustomerPubSub.LogType
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = KustomerPubSub.LogType
  public typealias Element = KustomerPubSub.LogType
  public typealias RawValue = Swift.UInt32
}
extension LogType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct KustomerPubNubV3Logger {
  public var writers: [KustomerPubSub.LogWriter]
  public var levels: KustomerPubSub.LogType
  public init(levels: KustomerPubSub.LogType = .all, writers: [KustomerPubSub.LogWriter])
  public func debug(_ message: @autoclosure () -> Any, date: Foundation.Date = Date(), queue: Swift.String = DispatchQueue.currentLabel, thread: Swift.String = Thread.currentName, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public func info(_ message: @autoclosure () -> Any, date: Foundation.Date = Date(), queue: Swift.String = DispatchQueue.currentLabel, thread: Swift.String = Thread.currentName, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public func event(_ message: @autoclosure () -> Any, date: Foundation.Date = Date(), queue: Swift.String = DispatchQueue.currentLabel, thread: Swift.String = Thread.currentName, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public func warn(_ message: @autoclosure () -> Any, date: Foundation.Date = Date(), queue: Swift.String = DispatchQueue.currentLabel, thread: Swift.String = Thread.currentName, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public func error(_ message: @autoclosure () -> Any, date: Foundation.Date = Date(), queue: Swift.String = DispatchQueue.currentLabel, thread: Swift.String = Thread.currentName, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public func custom(_ level: KustomerPubSub.LogType, _ message: @autoclosure () -> Any, date: Foundation.Date = Date(), queue: Swift.String = DispatchQueue.currentLabel, thread: Swift.String = Thread.currentName, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public func format(prefix: KustomerPubSub.LogPrefix, level: KustomerPubSub.LogType, date: Foundation.Date, queue: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int) -> Swift.String
  public func send(_ level: KustomerPubSub.LogType, message: @autoclosure () -> Any, date: Foundation.Date, queue: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int)
  public var enabled: Swift.Bool {
    get
  }
}
public struct AnyJSON {
  public init(_ value: Any)
  public init(reverse stringify: Swift.String)
  public var isEmpty: Swift.Bool {
    get
  }
}
extension AnyJSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
}
public enum AnyJSONIndex : Swift.Comparable {
  case arrayIndex(Swift.Int)
  case dictionaryIndex(Swift.DictionaryIndex<Swift.String, Any>)
  case null
  public static func == (lhs: KustomerPubSub.AnyJSONIndex, rhs: KustomerPubSub.AnyJSONIndex) -> Swift.Bool
  public static func < (lhs: KustomerPubSub.AnyJSONIndex, rhs: KustomerPubSub.AnyJSONIndex) -> Swift.Bool
}
extension AnyJSON : Swift.Collection {
  public var startIndex: KustomerPubSub.AnyJSONIndex {
    get
  }
  public var endIndex: KustomerPubSub.AnyJSONIndex {
    get
  }
  public func index(after index: KustomerPubSub.AnyJSONIndex) -> KustomerPubSub.AnyJSONIndex
  public subscript(position: KustomerPubSub.AnyJSONIndex) -> (Swift.String, KustomerPubSub.AnyJSON) {
    get
  }
  public subscript(rawValue position: KustomerPubSub.AnyJSONIndex) -> (Swift.String, Any)? {
    get
  }
  public subscript(key: Swift.String) -> KustomerPubSub.AnyJSON? {
    get
  }
  public subscript(rawValue key: Swift.String) -> Any? {
    get
  }
  public typealias Element = (Swift.String, KustomerPubSub.AnyJSON)
  public typealias Index = KustomerPubSub.AnyJSONIndex
  public typealias Indices = Swift.DefaultIndices<KustomerPubSub.AnyJSON>
  public typealias Iterator = Swift.IndexingIterator<KustomerPubSub.AnyJSON>
  public typealias SubSequence = Swift.Slice<KustomerPubSub.AnyJSON>
}
extension AnyJSON : Swift.Hashable {
  public static func == (lhs: KustomerPubSub.AnyJSON, rhs: KustomerPubSub.AnyJSON) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AnyJSON {
  public var underlyingValue: Any {
    get
  }
  public var isNil: Swift.Bool {
    get
  }
  public var stringOptional: Swift.String? {
    get
  }
  public var dataOptional: Foundation.Data? {
    get
  }
  public var boolOptional: Swift.Bool? {
    get
  }
  public var intOptional: Swift.Int? {
    get
  }
  public var doubleOptional: Swift.Double? {
    get
  }
  public var arrayOptional: [Any]? {
    get
  }
  public var wrappedUnderlyingArray: [KustomerPubSub.AnyJSON] {
    get
  }
  public var dictionaryOptional: [Swift.String : Any]? {
    get
  }
  public var wrappedUnderlyingDictionary: [Swift.String : KustomerPubSub.AnyJSON] {
    get
  }
}
extension AnyJSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyJSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Swift.Codable...)
  public typealias ArrayLiteralElement = Swift.Codable
}
extension AnyJSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.Codable)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.Codable
}
extension AnyJSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension AnyJSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension AnyJSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension AnyJSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
public struct KustomerPubNubV3Configuration : Swift.Hashable {
  public init(from bundle: Foundation.Bundle = .main, publishKeyAt pubPlistKey: Swift.String = "KustomerPubNubV3PublishKey", subscrbeKeyAt subPlistKey: Swift.String = "KustomerPubNubV3SubscribeKey")
  public init(publishKey: Swift.String?, subscribeKey: Swift.String, cipherKey: KustomerPubSub.Crypto? = nil, authKey: Swift.String? = nil, uuid: Swift.String? = nil, useSecureConnections: Swift.Bool = true, origin: Swift.String = "ps.pndsn.com", useInstanceId: Swift.Bool = false, useRequestId: Swift.Bool = false, automaticRetry: KustomerPubSub.AutomaticRetry? = nil, urlSessionConfiguration: Foundation.URLSessionConfiguration = .pubnub, durationUntilTimeout: Swift.UInt = 300, heartbeatInterval: Swift.UInt = 0, supressLeaveEvents: Swift.Bool = false, requestMessageCountThreshold: Swift.UInt = 100, filterExpression: Swift.String? = nil)
  public var publishKey: Swift.String?
  public var subscribeKey: Swift.String
  public var cipherKey: KustomerPubSub.Crypto?
  public var authKey: Swift.String?
  public var uuid: Swift.String
  public var useSecureConnections: Swift.Bool
  public var origin: Swift.String
  public var useInstanceId: Swift.Bool
  public var useRequestId: Swift.Bool
  public var automaticRetry: KustomerPubSub.AutomaticRetry?
  public var urlSessionConfiguration: Foundation.URLSessionConfiguration
  @KustomerPubSub.BoundedValue public var durationUntilTimeout: Swift.UInt {
    get
    set
    _modify
  }
  public var heartbeatInterval: Swift.UInt
  public var supressLeaveEvents: Swift.Bool
  public var requestMessageCountThreshold: Swift.UInt
  public var filterExpression: Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3Configuration, b: KustomerPubSub.KustomerPubNubV3Configuration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct EndpointResponse<Value> {
  public let router: KustomerPubSub.HTTPRouter
  public let request: Foundation.URLRequest
  public let response: Foundation.HTTPURLResponse
  public let data: Foundation.Data?
  public let payload: Value
}
public struct KustomerPubNubV3 {
  public let instanceID: Foundation.UUID
  public let configuration: KustomerPubSub.KustomerPubNubV3Configuration
  public let networkSession: KustomerPubSub.SessionReplaceable
  public let subscription: KustomerPubSub.KUSSubscriptionSession
  public static var log: KustomerPubSub.KustomerPubNubV3Logger
  public static var logLog: KustomerPubSub.KustomerPubNubV3Logger
  public init(configuration: KustomerPubSub.KustomerPubNubV3Configuration, session: KustomerPubSub.SessionReplaceable? = nil, subscribeSession: KustomerPubSub.SessionReplaceable? = nil, presenceSession: KustomerPubSub.SessionReplaceable? = nil)
}
extension KustomerPubNubV3 {
  public enum PushEnvironment : Swift.String, Swift.Codable {
    case development
    case production
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum PushService : Swift.String, Swift.Codable {
    case apns
    case gcm
    case mpns
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct RequestConfiguration {
    public var customSession: KustomerPubSub.SessionReplaceable?
    public var customConfiguration: KustomerPubSub.RouterConfiguration?
    public var responseQueue: Dispatch.DispatchQueue
    public init(customSession: KustomerPubSub.SessionReplaceable? = nil, customConfiguration: KustomerPubSub.RouterConfiguration? = nil, responseQueue: Dispatch.DispatchQueue = .main)
  }
  public struct Page : KustomerPubSub.KustomerPubNubV3HashedPage {
    public var start: Swift.String?
    public var end: Swift.String?
    public let totalCount: Swift.Int?
    public init(start: Swift.String? = nil, end: Swift.String? = nil)
    public init(from other: KustomerPubSub.KustomerPubNubV3HashedPage) throws
  }
  public struct IncludeFields {
    public var customFields: Swift.Bool
    public var totalCount: Swift.Bool
    public init(custom: Swift.Bool = true, totalCount: Swift.Bool = true)
  }
  public enum ObjectSortProperty : Swift.String {
    case id
    case name
    case updated
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct ObjectSortField {
    public let property: KustomerPubSub.KustomerPubNubV3.ObjectSortProperty
    public let ascending: Swift.Bool
    public init(property: KustomerPubSub.KustomerPubNubV3.ObjectSortProperty, ascending: Swift.Bool = true)
  }
  public enum MembershipSortProperty {
    case object(KustomerPubSub.KustomerPubNubV3.ObjectSortProperty)
    case updated
  }
  public struct MembershipSortField {
    public let property: KustomerPubSub.KustomerPubNubV3.MembershipSortProperty
    public let ascending: Swift.Bool
    public init(property: KustomerPubSub.KustomerPubNubV3.MembershipSortProperty, ascending: Swift.Bool = true)
  }
  public struct MembershipInclude {
    public var customFields: Swift.Bool
    public var channelFields: Swift.Bool
    public var channelCustomFields: Swift.Bool
    public var totalCount: Swift.Bool
    public init(customFields: Swift.Bool = true, channelFields: Swift.Bool = false, channelCustomFields: Swift.Bool = false, totalCount: Swift.Bool = false)
  }
  public struct MemberInclude {
    public var customFields: Swift.Bool
    public var uuidFields: Swift.Bool
    public var uuidCustomFields: Swift.Bool
    public var totalCount: Swift.Bool
    public init(customFields: Swift.Bool = true, uuidFields: Swift.Bool = false, uuidCustomFields: Swift.Bool = false, totalCount: Swift.Bool = false)
  }
}
extension KustomerPubNubV3 {
  public func time(custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KUSPNTtoken, Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func publish(channel: Swift.String, message: KustomerPubSub.JSONCodable, shouldStore: Swift.Bool? = nil, storeTTL: Swift.Int? = nil, meta: KustomerPubSub.JSONCodable? = nil, shouldCompress: Swift.Bool = false, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KUSPNTtoken, Swift.Error>) -> Swift.Void)?)
  public func fire(channel: Swift.String, message: KustomerPubSub.JSONCodable, meta: KustomerPubSub.JSONCodable? = nil, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KUSPNTtoken, Swift.Error>) -> Swift.Void)?)
  public func signal(channel: Swift.String, message: KustomerPubSub.JSONCodable, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KUSPNTtoken, Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func subscribe(to channels: [Swift.String], and channelGroups: [Swift.String] = [], at timetoken: KustomerPubSub.KUSPNTtoken? = nil, withPresence: Swift.Bool = false, filterOverride: Swift.String? = nil)
  public func unsubscribe(from channels: [Swift.String], and channelGroups: [Swift.String] = [], presenceOnly: Swift.Bool = false)
  public func unsubscribeAll()
  public func disconnect()
  public func reconnect(at timetoken: KustomerPubSub.KUSPNTtoken? = nil)
  public var previousTimetoken: KustomerPubSub.KUSPNTtoken? {
    get
  }
  public func add(_ listener: KustomerPubSub.SubscriptionListener)
  public var subscribedChannels: [Swift.String] {
    get
  }
  public var subscribedChannelGroups: [Swift.String] {
    get
  }
  public var subscriptionCount: Swift.Int {
    get
  }
  public var connectionStatus: KustomerPubSub.KUSPubSubConnectionStatus {
    get
  }
}
extension KustomerPubNubV3 {
  public func setPresence(state: [Swift.String : KustomerPubSub.JSONCodableScalar], on channels: [Swift.String], and groups: [Swift.String] = [], custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.JSONCodable, Swift.Error>) -> Swift.Void)?)
  public func getPresenceState(for uuid: Swift.String, on channels: [Swift.String], and groups: [Swift.String] = [], custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(uuid: Swift.String, stateByChannel: [Swift.String : KustomerPubSub.JSONCodable]), Swift.Error>) -> Swift.Void)?)
  public func hereNow(on channels: [Swift.String], and groups: [Swift.String] = [], includeUUIDs: Swift.Bool = true, includeState: Swift.Bool = false, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String : KustomerPubSub.KustomerPubNubV3Presence], Swift.Error>) -> Swift.Void)?)
  public func whereNow(for uuid: Swift.String, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String : [Swift.String]], Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func listChannelGroups(custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func remove(channelGroup: Swift.String, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)?)
  public func listChannels(for group: Swift.String, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(group: Swift.String, channels: [Swift.String]), Swift.Error>) -> Swift.Void)?)
  public func add(channels: [Swift.String], to group: Swift.String, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(group: Swift.String, channels: [Swift.String]), Swift.Error>) -> Swift.Void)?)
  public func remove(channels: [Swift.String], from group: Swift.String, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(group: Swift.String, channels: [Swift.String]), Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func listPushChannelRegistrations(for deviceToken: Foundation.Data, of pushType: KustomerPubSub.KustomerPubNubV3.PushService = .apns, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func managePushChannelRegistrations(byRemoving removals: [Swift.String], thenAdding additions: [Swift.String], for deviceToken: Foundation.Data, of pushType: KustomerPubSub.KustomerPubNubV3.PushService = .apns, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(added: [Swift.String], removed: [Swift.String]), Swift.Error>) -> Swift.Void)?)
  public func addPushChannelRegistrations(_ additions: [Swift.String], for deviceToken: Foundation.Data, of pushType: KustomerPubSub.KustomerPubNubV3.PushService = .apns, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func removePushChannelRegistrations(_ removals: [Swift.String], for deviceToken: Foundation.Data, of pushType: KustomerPubSub.KustomerPubNubV3.PushService = .apns, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func removeAllPushChannelRegistrations(for deviceToken: Foundation.Data, of pushType: KustomerPubSub.KustomerPubNubV3.PushService = .apns, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  public func listAPNSPushChannelRegistrations(for deviceToken: Foundation.Data, on topic: Swift.String, environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment = .development, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func manageAPNSDevicesOnChannels(byRemoving removals: [Swift.String], thenAdding additions: [Swift.String], device token: Foundation.Data, on topic: Swift.String, environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment = .development, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(added: [Swift.String], removed: [Swift.String]), Swift.Error>) -> Swift.Void)?)
  public func addAPNSDevicesOnChannels(_ additions: [Swift.String], device token: Foundation.Data, on topic: Swift.String, environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment = .development, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func removeAPNSDevicesOnChannels(_ removals: [Swift.String], device token: Foundation.Data, on topic: Swift.String, environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment = .development, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String], Swift.Error>) -> Swift.Void)?)
  public func removeAllAPNSPushDevice(for deviceToken: Foundation.Data, on topic: Swift.String, environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment = .development, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func fetchMessageHistory(for channels: [Swift.String], includeActions actions: Swift.Bool = false, includeMeta: Swift.Bool = false, page: KustomerPubSub.KustomerPubNubV3BoundedPage? = KustomerPubNubV3BoundedPageBase(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(messagesByChannel: [Swift.String : [KustomerPubSub.KustomerPubNubV3Message]], next: KustomerPubSub.KustomerPubNubV3BoundedPage?), Swift.Error>) -> Swift.Void)?)
  public func deleteMessageHistory(from channel: Swift.String, start: KustomerPubSub.KUSPNTtoken? = nil, end: KustomerPubSub.KUSPNTtoken? = nil, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  public func messageCounts(channels: [Swift.String : KustomerPubSub.KUSPNTtoken], custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String : Swift.Int], Swift.Error>) -> Swift.Void)?)
  public func messageCounts(channels: [Swift.String], timetoken: KustomerPubSub.KUSPNTtoken = 1, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<[Swift.String : Swift.Int], Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func allUUIDMetadata(include: KustomerPubSub.KustomerPubNubV3.IncludeFields = IncludeFields(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.ObjectSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(uuids: [KustomerPubSub.KustomerPubNubV3UUIDMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPage?), Swift.Error>) -> Swift.Void)?)
  public func fetch(uuid metadata: Swift.String?, include customFields: Swift.Bool = true, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KustomerPubNubV3UUIDMetadata, Swift.Error>) -> Swift.Void)?)
  public func set(uuid metadata: KustomerPubSub.KustomerPubNubV3UUIDMetadata, include customFields: Swift.Bool = true, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KustomerPubNubV3UUIDMetadata, Swift.Error>) -> Swift.Void)?)
  public func remove(uuid metadataId: Swift.String?, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func allChannelMetadata(include: KustomerPubSub.KustomerPubNubV3.IncludeFields = IncludeFields(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.ObjectSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(channels: [KustomerPubSub.KustomerPubNubV3ChannelMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func fetch(channel metadataId: Swift.String, include customFields: Swift.Bool = true, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KustomerPubNubV3ChannelMetadata, Swift.Error>) -> Swift.Void)?)
  public func set(channel metadata: KustomerPubSub.KustomerPubNubV3ChannelMetadata, include customFields: Swift.Bool = true, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KustomerPubNubV3ChannelMetadata, Swift.Error>) -> Swift.Void)?)
  public func remove(channel metadataId: Swift.String, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func fetchMemberships(uuid: Swift.String?, include: KustomerPubSub.KustomerPubNubV3.MembershipInclude = MembershipInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func fetchMembers(channel metadataId: Swift.String, include: KustomerPubSub.KustomerPubNubV3.MemberInclude = MemberInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func setMemberships(uuid metadataId: Swift.String?, channels memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], include: KustomerPubSub.KustomerPubNubV3.MembershipInclude = MembershipInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func removeMemberships(uuid metadataId: Swift.String?, channels memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], include: KustomerPubSub.KustomerPubNubV3.MembershipInclude = MembershipInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = nil, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func manageMemberships(uuid: Swift.String?, setting channelMembershipSets: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], removing channelMembershipDeletes: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], include: KustomerPubSub.KustomerPubNubV3.MembershipInclude = MembershipInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func setMembers(channel metadataId: Swift.String, uuids members: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], include: KustomerPubSub.KustomerPubNubV3.MemberInclude = MemberInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func removeMembers(channel metadataId: Swift.String, uuids members: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], include: KustomerPubSub.KustomerPubNubV3.MemberInclude = MemberInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
  public func manageMembers(channel metadataId: Swift.String, setting uuidMembershipSets: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], removing uuidMembershipDeletes: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], include: KustomerPubSub.KustomerPubNubV3.MemberInclude = MemberInclude(), filter: Swift.String? = nil, sort: [KustomerPubSub.KustomerPubNubV3.MembershipSortField] = [], limit: Swift.Int? = 100, page: KustomerPubSub.KustomerPubNubV3HashedPage? = Page(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(memberships: [KustomerPubSub.KustomerPubNubV3MembershipMetadata], next: KustomerPubSub.KustomerPubNubV3HashedPageBase?), Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func fetchMessageActions(channel: Swift.String, page: KustomerPubSub.KustomerPubNubV3BoundedPage? = KustomerPubNubV3BoundedPageBase(), custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(actions: [KustomerPubSub.KustomerPubNubV3MessageAction], next: KustomerPubSub.KustomerPubNubV3BoundedPage?), Swift.Error>) -> Swift.Void)?)
  public func addMessageAction(channel: Swift.String, type actionType: Swift.String, value: Swift.String, messageTimetoken: KustomerPubSub.KUSPNTtoken, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<KustomerPubSub.KustomerPubNubV3MessageAction, Swift.Error>) -> Swift.Void)?)
  public func removeMessageActions(channel: Swift.String, message timetoken: KustomerPubSub.KUSPNTtoken, action actionTimetoken: KustomerPubSub.KUSPNTtoken, custom requestConfig: KustomerPubSub.KustomerPubNubV3.RequestConfiguration = RequestConfiguration(), completion: ((Swift.Result<(channel: Swift.String, message: KustomerPubSub.KUSPNTtoken, action: KustomerPubSub.KUSPNTtoken), Swift.Error>) -> Swift.Void)?)
}
extension KustomerPubNubV3 {
  public func getToken(for identifier: Swift.String, with type: KustomerPubSub.PAMResourceType? = nil) -> KustomerPubSub.PAMToken?
  public func getTokens(by type: KustomerPubSub.PAMResourceType) -> KustomerPubSub.PAMTokenStore
  public func getAllTokens() -> [KustomerPubSub.PAMResourceType : KustomerPubSub.PAMTokenStore]
  public mutating func set(token: Swift.String)
  public mutating func set(tokens: [Swift.String])
}
public typealias KUSPNTtoken = Swift.UInt64
public typealias PAMTokenStore = [Swift.String : KustomerPubSub.PAMToken]
public typealias PAMResourceType = KustomerPubSub.PAMTokenManagementSystem.Resource
extension KustomerPubNubV3UUIDMetadataChangeset : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension KustomerPubNubV3ChannelMetadataChangeset : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct AutomaticRetry : KustomerPubSub.RequestOperator, Swift.Hashable {
  public static var `default`: KustomerPubSub.AutomaticRetry
  public static var none: KustomerPubSub.AutomaticRetry
  public static var connectionLost: KustomerPubSub.AutomaticRetry
  public static var noInternet: KustomerPubSub.AutomaticRetry
  public enum ReconnectionPolicy : Swift.Hashable {
    public static let defaultExponential: KustomerPubSub.AutomaticRetry.ReconnectionPolicy
    public static let defaultLinear: KustomerPubSub.AutomaticRetry.ReconnectionPolicy
    case immediately
    case exponential(base: Swift.UInt, scale: Swift.Double, maxDelay: Swift.UInt)
    case linear(delay: Swift.Double)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: KustomerPubSub.AutomaticRetry.ReconnectionPolicy, b: KustomerPubSub.AutomaticRetry.ReconnectionPolicy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public let retryLimit: Swift.UInt
  public let policy: KustomerPubSub.AutomaticRetry.ReconnectionPolicy
  public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = 2, policy: KustomerPubSub.AutomaticRetry.ReconnectionPolicy = .defaultExponential, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = [500], retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = AutomaticRetry.defaultRetryableURLErrorCodes)
  public func retry(_ request: KustomerPubSub.RequestReplaceable, for _: KustomerPubSub.SessionReplaceable, dueTo error: Swift.Error, completion: @escaping (Swift.Result<Foundation.TimeInterval, Swift.Error>) -> Swift.Void)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.AutomaticRetry, b: KustomerPubSub.AutomaticRetry) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KUSSubscriptionSession {
  final public let uuid: Foundation.UUID
  public var filterExpression: Swift.String?
  public var subscribedChannels: [Swift.String] {
    get
  }
  public var subscribedChannelGroups: [Swift.String] {
    get
  }
  public var subscriptionCount: Swift.Int {
    get
  }
  public var connectionStatus: KustomerPubSub.KUSPubSubConnectionStatus {
    get
  }
  @objc deinit
  public func subscribe(to channels: [Swift.String], and groups: [Swift.String] = [], at cursor: KustomerPubSub.SubscribeCursor? = nil, withPresence: Swift.Bool = false)
  public func reconnect(at cursor: KustomerPubSub.SubscribeCursor? = nil)
  public func disconnect()
  public func unsubscribe(from channels: [Swift.String], and groups: [Swift.String] = [], presenceOnly: Swift.Bool = false)
  public func unsubscribeAll()
}
extension KUSSubscriptionSession : KustomerPubSub.EventStreamEmitter {
  public typealias ListenerType = KustomerPubSub.SubscriptionListener
  public var listeners: [KustomerPubSub.KUSSubscriptionSession.ListenerType] {
    get
  }
  public func add(_ listener: KustomerPubSub.KUSSubscriptionSession.ListenerType)
  public func notify(listeners closure: (KustomerPubSub.KUSSubscriptionSession.ListenerType) -> Swift.Void)
}
extension KUSSubscriptionSession : Swift.Hashable, Swift.CustomStringConvertible {
  public static func == (lhs: KustomerPubSub.KUSSubscriptionSession, rhs: KustomerPubSub.KUSSubscriptionSession) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KUSSubscribeSessionFactory {
  final public let subscribeQueue: Dispatch.DispatchQueue
  public static var shared: KustomerPubSub.KUSSubscribeSessionFactory
  public func getSession(from config: KustomerPubSub.SubscriptionConfiguration, with subscribeSession: KustomerPubSub.SessionReplaceable? = nil, presenceSession: KustomerPubSub.SessionReplaceable? = nil) -> KustomerPubSub.KUSSubscriptionSession
  @objc deinit
}
public protocol SubscriptionConfiguration : KustomerPubSub.RouterConfiguration {
  var automaticRetry: KustomerPubSub.AutomaticRetry? { get }
  var durationUntilTimeout: Swift.UInt { get }
  var heartbeatInterval: Swift.UInt { get }
  var supressLeaveEvents: Swift.Bool { get }
  var requestMessageCountThreshold: Swift.UInt { get }
  var filterExpression: Swift.String? { get }
}
extension KustomerPubNubV3Configuration : KustomerPubSub.SubscriptionConfiguration {
}
public struct SubscribeCursor : Swift.Codable, Swift.Hashable {
  public let timetoken: KustomerPubSub.KUSPNTtoken
  public let region: Swift.Int
  public init(timetoken: KustomerPubSub.KUSPNTtoken, region: Swift.Int)
  public init?(timetoken: KustomerPubSub.KUSPNTtoken? = nil, region: Swift.Int? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: KustomerPubSub.SubscribeCursor, b: KustomerPubSub.SubscribeCursor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension String {
  public var jsonDescription: Swift.String {
    get
  }
}
extension UInt64 {
  public var timetokenDate: Foundation.Date {
    get
  }
}
public protocol KustomerPubNubV3MessageAction {
  var actionType: Swift.String { get }
  var actionValue: Swift.String { get }
  var actionTimetoken: KustomerPubSub.KUSPNTtoken { get }
  var messageTimetoken: KustomerPubSub.KUSPNTtoken { get }
  var publisher: Swift.String { get }
  var channel: Swift.String { get }
  var subscription: Swift.String? { get }
  var published: KustomerPubSub.KUSPNTtoken? { get }
  init(from other: KustomerPubSub.KustomerPubNubV3MessageAction) throws
}
extension KustomerPubNubV3MessageAction {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3MessageAction
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3MessageAction
}
public struct KustomerPubNubV3MessageActionBase : KustomerPubSub.KustomerPubNubV3MessageAction, Swift.Codable, Swift.Hashable {
  public let actionType: Swift.String
  public let actionValue: Swift.String
  public let actionTimetoken: KustomerPubSub.KUSPNTtoken
  public let messageTimetoken: KustomerPubSub.KUSPNTtoken
  public let publisher: Swift.String
  public let channel: Swift.String
  public let subscription: Swift.String?
  public let published: KustomerPubSub.KUSPNTtoken?
  public init(from other: KustomerPubSub.KustomerPubNubV3MessageAction) throws
  public init(actionType: Swift.String, actionValue: Swift.String, actionTimetoken: KustomerPubSub.KUSPNTtoken, messageTimetoken: KustomerPubSub.KUSPNTtoken, publisher: Swift.String, channel: Swift.String, subscription: Swift.String? = nil, published: KustomerPubSub.KUSPNTtoken? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3MessageActionBase, b: KustomerPubSub.KustomerPubNubV3MessageActionBase) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol SessionStream : KustomerPubSub.EventStreamReceiver {
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didCreate urlRequest: Foundation.URLRequest)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didFailToCreateURLRequestWith error: Swift.Error)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didCreate task: Foundation.URLSessionTask)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didResume task: Foundation.URLSessionTask)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didCancel task: Foundation.URLSessionTask)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didComplete task: Foundation.URLSessionTask)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didComplete task: Foundation.URLSessionTask, with error: Swift.Error)
  func emitRequestDidResume(_ request: KustomerPubSub.RequestReplaceable)
  func emitRequestDidFinish(_ request: KustomerPubSub.RequestReplaceable)
  func emitRequestDidCancel(_ request: KustomerPubSub.RequestReplaceable)
  func emitRequestIsRetrying(_ request: KustomerPubSub.RequestReplaceable)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didMutate initialURLRequest: Foundation.URLRequest, to mutatedURLRequest: Foundation.URLRequest)
  func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didFailToMutate initialURLRequest: Foundation.URLRequest, with error: Swift.Error)
  func emitURLSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func emitURLSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWith error: Swift.Error?)
  func emitURLSession(_ session: Foundation.URLSession, didBecomeInvalidWith error: Swift.Error?)
  func emitURLSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge)
}
extension SessionStream {
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didCreate _: Foundation.URLRequest)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didFailToCreateURLRequestWith _: Swift.Error)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didCreate _: Foundation.URLSessionTask)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didResume _: Foundation.URLSessionTask)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didCancel _: Foundation.URLSessionTask)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didComplete _: Foundation.URLSessionTask)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didComplete _: Foundation.URLSessionTask, with _: Swift.Error)
  public func emitRequestDidResume(_: KustomerPubSub.RequestReplaceable)
  public func emitRequestDidFinish(_: KustomerPubSub.RequestReplaceable)
  public func emitRequestDidCancel(_: KustomerPubSub.RequestReplaceable)
  public func emitRequestIsRetrying(_: KustomerPubSub.RequestReplaceable)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didMutate _: Foundation.URLRequest, to _: Foundation.URLRequest)
  public func emitRequest(_: KustomerPubSub.RequestReplaceable, didFailToMutate _: Foundation.URLRequest, with _: Swift.Error)
  public func emitURLSession(_: Foundation.URLSession, dataTask _: Foundation.URLSessionDataTask, didReceive _: Foundation.Data)
  public func emitURLSession(_: Foundation.URLSession, task _: Foundation.URLSessionTask, didCompleteWith _: Swift.Error?)
  public func emitURLSession(_: Foundation.URLSession, didBecomeInvalidWith _: Swift.Error?)
}
final public class MultiplexSessionStream : KustomerPubSub.SessionStream, Swift.Hashable {
  final public let queue: Dispatch.DispatchQueue
  final public let uuid: Foundation.UUID
  final public let streams: [KustomerPubSub.SessionStream]
  public init(_ streams: [KustomerPubSub.SessionStream], queue: Dispatch.DispatchQueue? = nil)
  public static func == (lhs: KustomerPubSub.MultiplexSessionStream, rhs: KustomerPubSub.MultiplexSessionStream) -> Swift.Bool
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didCreate urlRequest: Foundation.URLRequest)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didFailToCreateURLRequestWith error: Swift.Error)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didCreate task: Foundation.URLSessionTask)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didResume task: Foundation.URLSessionTask)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didCancel task: Foundation.URLSessionTask)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didComplete task: Foundation.URLSessionTask)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didComplete task: Foundation.URLSessionTask, with error: Swift.Error)
  final public func emitRequestDidResume(_ request: KustomerPubSub.RequestReplaceable)
  final public func emitRequestDidFinish(_ request: KustomerPubSub.RequestReplaceable)
  final public func emitRequestDidCancel(_ request: KustomerPubSub.RequestReplaceable)
  final public func emitRequestIsRetrying(_ request: KustomerPubSub.RequestReplaceable)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didMutate initialURLRequest: Foundation.URLRequest, to mutatedURLRequest: Foundation.URLRequest)
  final public func emitRequest(_ request: KustomerPubSub.RequestReplaceable, didFailToMutate initialURLRequest: Foundation.URLRequest, with error: Swift.Error)
  final public func emitURLSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func emitURLSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWith error: Swift.Error?)
  final public func emitURLSession(_ session: Foundation.URLSession, didBecomeInvalidWith error: Swift.Error?)
  final public func emitURLSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge)
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
@propertyWrapper public struct BoundedValue<Value> : Swift.Comparable where Value : Swift.Comparable {
  public static func < (lhs: KustomerPubSub.BoundedValue<Value>, rhs: KustomerPubSub.BoundedValue<Value>) -> Swift.Bool
  public var wrappedValue: Value {
    get
    set
  }
  public static func == (a: KustomerPubSub.BoundedValue<Value>, b: KustomerPubSub.BoundedValue<Value>) -> Swift.Bool
}
extension BoundedValue : Swift.Hashable where Value : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FCMWebpushConfig : Swift.Codable, Swift.Hashable {
  public let headers: [Swift.String : Swift.String]?
  public let notification: Swift.String?
  public let options: KustomerPubSub.FCMWebpushFcmOptions?
  public init(headers: [Swift.String : Swift.String]? = nil, notification: Swift.String? = nil, options: KustomerPubSub.FCMWebpushFcmOptions? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMWebpushConfig, b: KustomerPubSub.FCMWebpushConfig) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct FCMWebpushNotification : Swift.Codable, Swift.Hashable {
  public let actions: [KustomerPubSub.FCMWebpushAction]?
  public let badge: Swift.String?
  public let body: Swift.String?
  public let dir: KustomerPubSub.FCMWebpushDirection?
  public let lang: Swift.String?
  public let tag: Swift.String?
  public let icon: Swift.String?
  public let image: Swift.String?
  public let renotify: Swift.Bool?
  public let requireInteraction: Swift.Bool?
  public let silent: Swift.Bool?
  public let timestamp: Foundation.Date?
  public let title: Swift.String?
  public let vibrate: [Swift.UInt]?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMWebpushNotification, b: KustomerPubSub.FCMWebpushNotification) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct FCMWebpushAction : Swift.Codable, Swift.Hashable {
  public let action: Swift.String?
  public let title: Swift.String?
  public let icon: Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMWebpushAction, b: KustomerPubSub.FCMWebpushAction) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum FCMWebpushDirection : Swift.String, Swift.Codable, Swift.Hashable {
  case auto
  case leftToRight
  case rightToLeft
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct FCMWebpushFcmOptions : Swift.Codable, Swift.Hashable {
  public let link: Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMWebpushFcmOptions, b: KustomerPubSub.FCMWebpushFcmOptions) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension Data {
  public var trulyEmpty: Swift.Bool {
    get
  }
  public var hexEncodedString: Swift.String {
    get
  }
  public init?(hexEncodedString: Swift.String)
}
public struct FCMAndroidPayload : Swift.Codable, Swift.Hashable {
  public let collapseKey: Swift.String?
  public let priority: KustomerPubSub.FCMAndroidMessagePriority?
  public let ttl: Swift.String?
  public let restrictedPackageName: Swift.String?
  public let notification: KustomerPubSub.FCMAndroidNotification?
  public let options: KustomerPubSub.FCMOptionsPayload?
  public init(collapseKey: Swift.String? = nil, priority: KustomerPubSub.FCMAndroidMessagePriority? = nil, ttl: Swift.Double? = nil, restrictedPackageName: Swift.String? = nil, notification: KustomerPubSub.FCMAndroidNotification? = nil, options: KustomerPubSub.FCMOptionsPayload? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMAndroidPayload, b: KustomerPubSub.FCMAndroidPayload) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum FCMAndroidMessagePriority : Swift.String, Swift.Codable, Swift.Hashable {
  case normal
  case high
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct FCMAndroidNotification : Swift.Codable, Swift.Hashable {
  public let title: Swift.String?
  public let body: Swift.String?
  public let icon: Swift.String?
  public let color: Swift.String?
  public let sound: Swift.String?
  public let tag: Swift.String?
  public let clickAction: Swift.String?
  public let bodyLocKey: Swift.String?
  public let bodyLocArgs: [Swift.String]?
  public let titleLocKey: Swift.String?
  public let titleLocArgs: [Swift.String]?
  public let channelID: Swift.String?
  public let ticker: Swift.String?
  public let sticky: Swift.Bool?
  public let eventTime: Foundation.Date?
  public let localOnly: Swift.Bool?
  public let notificationPriority: KustomerPubSub.FCMAndroidNotificationPriority?
  public let defaultSound: Swift.Bool?
  public let defaultVibrateTimings: Swift.Bool?
  public let defaultLightSettings: Swift.Bool?
  public let vibrateTimings: [Swift.String]?
  public let visibility: KustomerPubSub.FCMAndroidVisibility?
  public let notificationCount: Swift.Int?
  public let lightSettings: KustomerPubSub.FCMAndroidLightSettings?
  public let image: Swift.String?
  public init(title: Swift.String? = nil, body: Swift.String? = nil, icon: Swift.String? = nil, color: Swift.String? = nil, sound: Swift.String? = nil, tag: Swift.String? = nil, clickAction: Swift.String? = nil, bodyLocKey: Swift.String? = nil, bodyLocArgs: [Swift.String]? = nil, titleLocKey: Swift.String? = nil, titleLocArgs: [Swift.String]? = nil, channelID: Swift.String? = nil, ticker: Swift.String? = nil, sticky: Swift.Bool? = nil, eventTime: Foundation.Date? = nil, localOnly: Swift.Bool? = nil, notificationPriority: KustomerPubSub.FCMAndroidNotificationPriority? = nil, defaultSound: Swift.Bool? = nil, defaultVibrateTimings: Swift.Bool? = nil, defaultLightSettings: Swift.Bool? = nil, vibrateTimings: [Swift.Double]? = nil, visibility: KustomerPubSub.FCMAndroidVisibility? = nil, notificationCount: Swift.Int? = nil, lightSettings: KustomerPubSub.FCMAndroidLightSettings? = nil, image: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMAndroidNotification, b: KustomerPubSub.FCMAndroidNotification) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum FCMAndroidVisibility : Swift.String, Swift.Codable, Swift.Hashable {
  case unspecified
  case `private`
  case `public`
  case secret
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FCMAndroidNotificationPriority : Swift.String, Swift.Codable, Swift.Hashable {
  case unspecified
  case min
  case low
  case `default`
  case high
  case max
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct FCMAndroidLightSettings : Swift.Codable, Swift.Hashable {
  public let color: KustomerPubSub.FCMColor
  public let onDuration: Swift.String
  public let offDuration: Swift.String
  public init(color: KustomerPubSub.FCMColor, onDuration: Swift.Double, offDuration: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMAndroidLightSettings, b: KustomerPubSub.FCMAndroidLightSettings) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct FCMColor : Swift.Codable, Swift.Hashable {
  public let red: Swift.Double
  public let green: Swift.Double
  public let blue: Swift.Double
  public let alpha: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.FCMColor, b: KustomerPubSub.FCMColor) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol RequestMutator {
  func mutate(_ urlRequest: Foundation.URLRequest, for session: KustomerPubSub.SessionReplaceable, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public protocol RequestRetrier {
  func retry(_ request: KustomerPubSub.RequestReplaceable, for session: KustomerPubSub.SessionReplaceable, dueTo error: Swift.Error, completion: @escaping (Swift.Result<Foundation.TimeInterval, Swift.Error>) -> Swift.Void)
}
public protocol RequestOperator : KustomerPubSub.RequestMutator, KustomerPubSub.RequestRetrier {
}
extension RequestOperator {
  public func mutate(_ urlRequest: Foundation.URLRequest, for _: KustomerPubSub.SessionReplaceable, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_: KustomerPubSub.RequestReplaceable, for _: KustomerPubSub.SessionReplaceable, dueTo error: Swift.Error, completion: @escaping (Swift.Result<Foundation.TimeInterval, Swift.Error>) -> Swift.Void)
  public func merge(operators: [KustomerPubSub.RequestOperator]) -> KustomerPubSub.RequestOperator
  public func merge(requestOperator: KustomerPubSub.RequestOperator?) -> KustomerPubSub.RequestOperator
}
public struct MultiplexRequestOperator : KustomerPubSub.RequestOperator {
  public let operators: [KustomerPubSub.RequestOperator]
  public init(requestOperator: KustomerPubSub.RequestOperator? = nil)
  public init(operators: [KustomerPubSub.RequestOperator] = [])
  public func mutate(_ urlRequest: Foundation.URLRequest, for session: KustomerPubSub.SessionReplaceable, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: KustomerPubSub.RequestReplaceable, for session: KustomerPubSub.SessionReplaceable, dueTo error: Swift.Error, completion: @escaping (Swift.Result<Foundation.TimeInterval, Swift.Error>) -> Swift.Void)
}
extension FileManager {
  public func newestFile(_ directory: Foundation.URL) -> Foundation.URL?
  public func oldestFile(_ directory: Foundation.URL) -> Foundation.URL?
  public func files(in directory: Foundation.URL) -> [Foundation.URL]
}
extension KustomerPubNubV3Error : Foundation.LocalizedError, Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
extension KustomerPubNubV3Error.Domain : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension KustomerPubNubV3Error.Reason : Swift.CustomStringConvertible, Foundation.LocalizedError {
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
}
extension DateFormatter {
  public var currentDateString: Swift.String {
    get
  }
  public static let iso8601: Foundation.DateFormatter
}
extension KUSSubscriptionSession {
  public func presenceLeave(for _: Swift.String, on channels: [Swift.String], and groups: [Swift.String], completion: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
}
extension Set {
  public var allObjects: [Element] {
    get
  }
}
public struct PAMTokenManagementSystem {
  public enum Resource {
    case uuid
    case channel
    public static func == (a: KustomerPubSub.PAMTokenManagementSystem.Resource, b: KustomerPubSub.PAMTokenManagementSystem.Resource) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(uuids: [Swift.String : KustomerPubSub.PAMToken] = [:], channels: [Swift.String : KustomerPubSub.PAMToken] = [:])
  public init(store: KustomerPubSub.PAMTokenManagementSystem)
  public func getToken(for identifier: Swift.String, with type: KustomerPubSub.PAMTokenManagementSystem.Resource? = nil) -> KustomerPubSub.PAMToken?
  public func getTokens(by resource: KustomerPubSub.PAMTokenManagementSystem.Resource) -> KustomerPubSub.PAMTokenStore
  public func getAllTokens() -> [KustomerPubSub.PAMTokenManagementSystem.Resource : KustomerPubSub.PAMTokenStore]
  public mutating func set(token tokenString: Swift.String)
  public mutating func set(tokens: [Swift.String])
}
public struct PAMToken : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let version: Swift.Int
  public let timestamp: Swift.Int
  public let ttl: Swift.Int
  public let resources: KustomerPubSub.PAMTokenResource
  public let patterns: KustomerPubSub.PAMTokenResource
  public let meta: [Swift.String : KustomerPubSub.AnyJSON]
  public let signature: Swift.String
  public var rawValue: Swift.String {
    get
  }
  public static func == (a: KustomerPubSub.PAMToken, b: KustomerPubSub.PAMToken) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct PAMTokenResource : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let channels: [Swift.String : KustomerPubSub.PAMPermission]
  public let groups: [Swift.String : KustomerPubSub.PAMPermission]
  public let uuidObjects: [Swift.String : KustomerPubSub.PAMPermission]
  public let channelObjects: [Swift.String : KustomerPubSub.PAMPermission]
  public static func == (a: KustomerPubSub.PAMTokenResource, b: KustomerPubSub.PAMTokenResource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct PAMPermission : Swift.OptionSet, Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let rawValue: Swift.UInt32
  public static let none: KustomerPubSub.PAMPermission
  public static let read: KustomerPubSub.PAMPermission
  public static let write: KustomerPubSub.PAMPermission
  public static let manage: KustomerPubSub.PAMPermission
  public static let delete: KustomerPubSub.PAMPermission
  public static let create: KustomerPubSub.PAMPermission
  public static let update: KustomerPubSub.PAMPermission
  public static let crud: KustomerPubSub.PAMPermission
  public static let all: KustomerPubSub.PAMPermission
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = KustomerPubSub.PAMPermission
  public typealias Element = KustomerPubSub.PAMPermission
  public typealias RawValue = Swift.UInt32
}
extension PAMPermission : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DispatchQueue {
  public static var currentLabel: Swift.String {
    get
  }
}
extension Array where Element == Foundation.URLQueryItem {
  public func merging(_ other: [Foundation.URLQueryItem]) -> [Foundation.URLQueryItem]
  public mutating func merge(_ other: [Foundation.URLQueryItem])
  public func firstIndex(of name: Swift.String) -> Swift.Int?
  public mutating func appendIfPresent(name: Swift.String, value: Swift.String?)
  public mutating func appendIfNotEmpty(name: Swift.String, value: [Swift.String])
}
public enum SubscriptionChangeEvent {
  case subscribed(channels: [KustomerPubSub.KustomerPubNubV3Channel], groups: [KustomerPubSub.KustomerPubNubV3Channel])
  case responseHeader(channels: [KustomerPubSub.KustomerPubNubV3Channel], groups: [KustomerPubSub.KustomerPubNubV3Channel], previous: KustomerPubSub.SubscribeCursor?, next: KustomerPubSub.SubscribeCursor?)
  case unsubscribed(channels: [KustomerPubSub.KustomerPubNubV3Channel], groups: [KustomerPubSub.KustomerPubNubV3Channel])
}
public enum SubscriptionEvent {
  case messageReceived(KustomerPubSub.KustomerPubNubV3Message)
  case signalReceived(KustomerPubSub.KustomerPubNubV3Message)
  case connectionStatusChanged(KustomerPubSub.KUSPubSubConnectionStatus)
  case subscriptionChanged(KustomerPubSub.SubscriptionChangeEvent)
  case presenceChanged(KustomerPubSub.KustomerPubNubV3PresenceChange)
  case uuidMetadataSet(KustomerPubSub.KustomerPubNubV3UUIDMetadataChangeset)
  case uuidMetadataRemoved(metadataId: Swift.String)
  case channelMetadataSet(KustomerPubSub.KustomerPubNubV3ChannelMetadataChangeset)
  case channelMetadataRemoved(metadataId: Swift.String)
  case membershipMetadataSet(KustomerPubSub.KustomerPubNubV3MembershipMetadata)
  case membershipMetadataRemoved(KustomerPubSub.KustomerPubNubV3MembershipMetadata)
  case messageActionAdded(KustomerPubSub.KustomerPubNubV3MessageAction)
  case messageActionRemoved(KustomerPubSub.KustomerPubNubV3MessageAction)
  case subscribeError(KustomerPubSub.KustomerPubNubV3Error)
}
public protocol SubscriptionStream : KustomerPubSub.EventStreamReceiver {
  func emitDidReceive(subscription event: KustomerPubSub.SubscriptionEvent)
  func emitDidReceiveBatch(subscription event: [KustomerPubSub.SubscriptionEvent])
}
final public class SubscriptionListener : KustomerPubSub.SubscriptionStream, Swift.Hashable {
  final public let uuid: Foundation.UUID
  final public var queue: Dispatch.DispatchQueue
  final public var supressCancellationErrors: Swift.Bool
  public init(queue: Dispatch.DispatchQueue = .main)
  @objc deinit
  public enum MessageActionEvent {
    case added(KustomerPubSub.KustomerPubNubV3MessageAction)
    case removed(KustomerPubSub.KustomerPubNubV3MessageAction)
  }
  public enum ObjectMetadataChangeEvents {
    case setUUID(KustomerPubSub.KustomerPubNubV3UUIDMetadataChangeset)
    case removedUUID(metadataId: Swift.String)
    case setChannel(KustomerPubSub.KustomerPubNubV3ChannelMetadataChangeset)
    case removedChannel(metadataId: Swift.String)
    case setMembership(KustomerPubSub.KustomerPubNubV3MembershipMetadata)
    case removedMembership(KustomerPubSub.KustomerPubNubV3MembershipMetadata)
  }
  public typealias StatusEvent = Swift.Result<KustomerPubSub.KUSPubSubConnectionStatus, KustomerPubSub.KustomerPubNubV3Error>
  final public var didReceiveBatchSubscription: (([KustomerPubSub.SubscriptionEvent]) -> Swift.Void)?
  final public var didReceiveSubscription: ((KustomerPubSub.SubscriptionEvent) -> Swift.Void)?
  final public var didReceiveMessage: ((KustomerPubSub.KustomerPubNubV3Message) -> Swift.Void)?
  final public var didReceiveStatus: ((KustomerPubSub.SubscriptionListener.StatusEvent) -> Swift.Void)?
  final public var didReceivePresence: ((KustomerPubSub.KustomerPubNubV3PresenceChange) -> Swift.Void)?
  final public var didReceiveSignal: ((KustomerPubSub.KustomerPubNubV3Message) -> Swift.Void)?
  final public var didReceiveSubscriptionChange: ((KustomerPubSub.SubscriptionChangeEvent) -> Swift.Void)?
  final public var didReceiveObjectMetadataEvent: ((KustomerPubSub.SubscriptionListener.ObjectMetadataChangeEvents) -> Swift.Void)?
  final public var didReceiveMessageAction: ((KustomerPubSub.SubscriptionListener.MessageActionEvent) -> Swift.Void)?
  final public func emitDidReceiveBatch(subscription batch: [KustomerPubSub.SubscriptionEvent])
  final public func emitDidReceive(subscription event: KustomerPubSub.SubscriptionEvent)
  public static func == (lhs: KustomerPubSub.SubscriptionListener, rhs: KustomerPubSub.SubscriptionListener) -> Swift.Bool
  final public var hashValue: Swift.Int {
    get
  }
}
extension SubscriptionListener : KustomerPubSub.Cancellable {
  final public var isCancelled: Swift.Bool {
    get
  }
  final public func cancel()
}
public protocol Validated {
  var validationError: Swift.Error? { get }
  var validationErrorDetail: Swift.String? { get }
}
extension Validated {
  public var isValid: Swift.Bool {
    get
  }
  public var validResult: Swift.Result<Self, Swift.Error> {
    get
  }
  public var validationErrorDetail: Swift.String? {
    get
  }
}
public protocol KustomerPubNubV3UUIDMetadata {
  var metadataId: Swift.String { get }
  var name: Swift.String { get set }
  var externalId: Swift.String? { get set }
  var profileURL: Swift.String? { get set }
  var email: Swift.String? { get set }
  var updated: Foundation.Date? { get set }
  var eTag: Swift.String? { get set }
  var custom: [Swift.String : KustomerPubSub.JSONCodableScalar]? { get set }
  init(from other: KustomerPubSub.KustomerPubNubV3UUIDMetadata) throws
}
extension KustomerPubNubV3UUIDMetadata {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3UUIDMetadata
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3UUIDMetadata
}
public struct KustomerPubNubV3UUIDMetadataBase : KustomerPubSub.KustomerPubNubV3UUIDMetadata, Swift.Hashable {
  public let metadataId: Swift.String
  public var name: Swift.String
  public var externalId: Swift.String?
  public var profileURL: Swift.String?
  public var email: Swift.String?
  public var updated: Foundation.Date?
  public var eTag: Swift.String?
  public var custom: [Swift.String : KustomerPubSub.JSONCodableScalar]? {
    get
    set
  }
  public init(metadataId: Swift.String = UUID().uuidString, name: Swift.String, externalId: Swift.String? = nil, profileURL: Swift.String? = nil, email: Swift.String? = nil, custom concreteCustom: [Swift.String : KustomerPubSub.JSONCodableScalar]? = nil, updated: Foundation.Date? = nil, eTag: Swift.String? = nil)
  public init(from other: KustomerPubSub.KustomerPubNubV3UUIDMetadata) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3UUIDMetadataBase, b: KustomerPubSub.KustomerPubNubV3UUIDMetadataBase) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerPubNubV3UUIDMetadataBase : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol ResponseDecoder {
  associatedtype Payload : Swift.Decodable, Swift.Encodable
  func decode(response: KustomerPubSub.EndpointResponse<Foundation.Data>) -> Swift.Result<KustomerPubSub.EndpointResponse<Self.Payload>, Swift.Error>
  func decodeError(router: KustomerPubSub.HTTPRouter, request: Foundation.URLRequest, response: Foundation.HTTPURLResponse, for data: Foundation.Data) -> KustomerPubSub.KustomerPubNubV3Error?
  func decrypt(response: KustomerPubSub.EndpointResponse<Self.Payload>) -> Swift.Result<KustomerPubSub.EndpointResponse<Self.Payload>, Swift.Error>
}
public struct KustomerPubNubV3PushConfig : Swift.Codable, Swift.Hashable {
  public let authMethod: Swift.String
  public let targets: [KustomerPubSub.KustomerPubNubV3PushTarget]
  public let version: Swift.String
  public let collapseID: Swift.String?
  public let expiration: Foundation.Date?
  public init(targets: [KustomerPubSub.KustomerPubNubV3PushTarget], collapseID: Swift.String? = nil, expiration: Foundation.Date? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3PushConfig, b: KustomerPubSub.KustomerPubNubV3PushConfig) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct KustomerPubNubV3PushTarget : Swift.Codable, Swift.Hashable {
  public let topic: Swift.String
  public let environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment
  public let excludedDevices: [Swift.String]?
  public init(topic: Swift.String, environment: KustomerPubSub.KustomerPubNubV3.PushEnvironment = .development, excludedDevices: [Swift.String]? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3PushTarget, b: KustomerPubSub.KustomerPubNubV3PushTarget) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct KustomerPubNubV3APNSPayload : Swift.Codable {
  public let aps: KustomerPubSub.APSPayload
  public let pubnub: [KustomerPubSub.KustomerPubNubV3PushConfig]
  public let payload: KustomerPubSub.JSONCodable?
  public init(aps: KustomerPubSub.APSPayload, pubnub: [KustomerPubSub.KustomerPubNubV3PushConfig], payload: KustomerPubSub.JSONCodable?)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct APSPayload : Swift.Codable, Swift.Hashable {
  public let alert: KustomerPubSub.APSAlert?
  public let badge: Swift.Int?
  public let sound: KustomerPubSub.APSSound?
  public let threadID: Swift.String?
  public let category: Swift.String?
  public let contentAvailable: Swift.Int?
  public let mutableContent: Swift.Int?
  public let targetContentID: Swift.String?
  public init(alert: KustomerPubSub.APSAlert? = nil, badge: Swift.Int? = nil, sound: KustomerPubSub.APSSound? = .string("default"), threadID: Swift.String? = nil, category: Swift.String? = nil, contentAvailable: Swift.Int? = nil, mutableContent: Swift.Int? = nil, targetContentID: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.APSPayload, b: KustomerPubSub.APSPayload) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum APSAlert : Swift.Codable, Swift.Hashable {
  case body(Swift.String)
  case object(KustomerPubSub.APSAlertObject)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.APSAlert, b: KustomerPubSub.APSAlert) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct APSAlertObject : Swift.Codable, Swift.Hashable {
  public let title: Swift.String?
  public let subtitle: Swift.String?
  public let body: Swift.String?
  public let launchImage: Swift.String?
  public let titleLocKey: Swift.String?
  public let titleLocArgs: [Swift.String]?
  public let subtitleLocKey: [Swift.String]?
  public let subtitleLocArgs: [Swift.String]?
  public let locKey: Swift.String?
  public let locArgs: [Swift.String]?
  public init(title: Swift.String? = nil, subtitle: Swift.String? = nil, body: Swift.String? = nil, launchImage: Swift.String? = nil, titleLocKey: Swift.String? = nil, titleLocArgs: [Swift.String]? = nil, subtitleLocKey: [Swift.String]? = nil, subtitleLocArgs: [Swift.String]? = nil, locKey: Swift.String? = nil, locArgs: [Swift.String]? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.APSAlertObject, b: KustomerPubSub.APSAlertObject) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum APSSound : Swift.Codable, Swift.Hashable {
  case string(Swift.String)
  case critical(KustomerPubSub.APSCriticalSound)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.APSSound, b: KustomerPubSub.APSSound) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct APSCriticalSound : Swift.Codable, Swift.Hashable {
  public let critical: Swift.Int?
  public let name: Swift.String
  public let volume: Swift.Int?
  public init(critical: Swift.Int? = nil, name: Swift.String = "default", volume: Swift.Int? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.APSCriticalSound, b: KustomerPubSub.APSCriticalSound) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct InstanceIdOperator : KustomerPubSub.RequestOperator {
  public let instanceID: Swift.String
  public func mutate(_ urlRequest: Foundation.URLRequest, for _: KustomerPubSub.SessionReplaceable, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
extension HTTPURLResponse {
  public var isSuccessful: Swift.Bool {
    get
  }
  public static let successfulStatusCodes: Swift.Range<Swift.Int>
}
extension URLSessionConfiguration {
  public static var pubnub: Foundation.URLSessionConfiguration {
    get
  }
  public static var subscription: Foundation.URLSessionConfiguration {
    get
  }
  public var headers: [Swift.String : Swift.String] {
    get
    set
  }
}
public protocol URLConvertible {
  var asURL: Swift.Result<Foundation.URL, Swift.Error> { get }
}
public enum URLConvertibleError : Swift.Error {
  case urlComponents
  public static func == (a: KustomerPubSub.URLConvertibleError, b: KustomerPubSub.URLConvertibleError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension URLComponents : KustomerPubSub.URLConvertible {
  public var asURL: Swift.Result<Foundation.URL, Swift.Error> {
    get
  }
}
public protocol URLRequestConvertible : KustomerPubSub.URLConvertible {
  var asURLRequest: Swift.Result<Foundation.URLRequest, Swift.Error> { get }
}
public enum AnyJSONType {
  case string(Swift.String)
  case integer(Foundation.NSNumber)
  case double(Foundation.NSNumber)
  case boolean(Swift.Bool)
  case null
  case array([KustomerPubSub.AnyJSONType])
  case dictionary([Swift.String : KustomerPubSub.AnyJSONType])
  case codable(Swift.Codable)
  case unknown(Any)
}
extension AnyJSONType : Swift.Codable {
  public func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension AnyJSONType : Swift.RawRepresentable {
  public var rawValue: Any {
    get
  }
  public var isNil: Swift.Bool {
    get
  }
  public init(rawValue: Any)
  public func rawValueAs<T>() -> T?
  public typealias RawValue = Any
}
extension AnyJSONType : Swift.Hashable {
  public static func == (lhs: KustomerPubSub.AnyJSONType, rhs: KustomerPubSub.AnyJSONType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KustomerPubNubV3MetadataChange<MetadataType> {
  case string(Swift.WritableKeyPath<MetadataType, Swift.String>, Swift.String)
  case stringOptional(Swift.WritableKeyPath<MetadataType, Swift.String?>, Swift.String?)
  case customOptional(Swift.WritableKeyPath<MetadataType, [Swift.String : KustomerPubSub.JSONCodableScalar]?>, [Swift.String : KustomerPubSub.JSONCodableScalar]?)
}
public struct KustomerPubNubV3UUIDMetadataChangeset {
  public let metadataId: Swift.String
  public let changes: [KustomerPubSub.KustomerPubNubV3MetadataChange<KustomerPubSub.KustomerPubNubV3UUIDMetadata>]
  public let updated: Foundation.Date
  public let eTag: Swift.String
  public init(metadataId: Swift.String, changes: [KustomerPubSub.KustomerPubNubV3MetadataChange<KustomerPubSub.KustomerPubNubV3UUIDMetadata>], updated: Foundation.Date, eTag: Swift.String)
  public func apply(to object: KustomerPubSub.KustomerPubNubV3UUIDMetadata) -> KustomerPubSub.KustomerPubNubV3UUIDMetadata
}
public struct KustomerPubNubV3ChannelMetadataChangeset {
  public let metadataId: Swift.String
  public let changes: [KustomerPubSub.KustomerPubNubV3MetadataChange<KustomerPubSub.KustomerPubNubV3ChannelMetadata>]
  public let updated: Foundation.Date
  public let eTag: Swift.String
  public init(metadataId: Swift.String, changes: [KustomerPubSub.KustomerPubNubV3MetadataChange<KustomerPubSub.KustomerPubNubV3ChannelMetadata>], updated: Foundation.Date, eTag: Swift.String)
  public func apply(to object: KustomerPubSub.KustomerPubNubV3ChannelMetadata) -> KustomerPubSub.KustomerPubNubV3ChannelMetadata
}
public struct Constant {
  public static let jsonDecoder: Foundation.JSONDecoder
  public static let jsonEncoder: Foundation.JSONEncoder
}
extension Constant {
  public static let acceptEncodingHeaderKey: Swift.String
  public static let defaultAcceptEncodingHeader: Swift.String
  public static let contentTypeHeaderKey: Swift.String
  public static let defaultContentTypeHeader: Swift.String
  public static let userAgentHeaderKey: Swift.String
}
extension Error {
  public var pubNubError: KustomerPubSub.KustomerPubNubV3Error? {
    get
  }
  public var urlError: Foundation.URLError? {
    get
  }
  public var isCancellationError: Swift.Bool {
    get
  }
  public var encodingError: Swift.EncodingError? {
    get
  }
  public var decodingError: Swift.DecodingError? {
    get
  }
}
extension UInt64 {
  public func toDate() -> Foundation.Date
}
extension Date {
  public func toPubNubTimetoken() -> KustomerPubSub.KUSPNTtoken
}
extension String {
  public func removeZeroWidthSpace() -> Swift.String
}
extension URLRequest {
  public var method: KustomerPubSub.HTTPMethod? {
    get
    set
  }
}
public protocol KustomerPubNubV3MembershipMetadata {
  var uuidMetadataId: Swift.String { get }
  var channelMetadataId: Swift.String { get }
  var uuid: KustomerPubSub.KustomerPubNubV3UUIDMetadata? { get set }
  var channel: KustomerPubSub.KustomerPubNubV3ChannelMetadata? { get set }
  var updated: Foundation.Date? { get set }
  var eTag: Swift.String? { get set }
  var custom: [Swift.String : KustomerPubSub.JSONCodableScalar]? { get set }
  init(from other: KustomerPubSub.KustomerPubNubV3MembershipMetadata) throws
}
extension KustomerPubNubV3MembershipMetadata {
  public func transcode<T>(into _: T.Type) throws -> T where T : KustomerPubSub.KustomerPubNubV3MembershipMetadata
  public func transcode<T>() throws -> T where T : KustomerPubSub.KustomerPubNubV3MembershipMetadata
}
public struct KustomerPubNubV3MembershipMetadataBase : KustomerPubSub.KustomerPubNubV3MembershipMetadata, Swift.Hashable {
  public let uuidMetadataId: Swift.String
  public let channelMetadataId: Swift.String
  public var uuid: KustomerPubSub.KustomerPubNubV3UUIDMetadata? {
    get
    set
  }
  public var channel: KustomerPubSub.KustomerPubNubV3ChannelMetadata? {
    get
    set
  }
  public var custom: [Swift.String : KustomerPubSub.JSONCodableScalar]? {
    get
    set
  }
  public var updated: Foundation.Date?
  public var eTag: Swift.String?
  public init(uuidMetadataId: Swift.String, channelMetadataId: Swift.String, uuid: KustomerPubSub.KustomerPubNubV3UUIDMetadataBase? = nil, channel: KustomerPubSub.KustomerPubNubV3ChannelMetadataBase? = nil, custom concreteCustom: [Swift.String : KustomerPubSub.JSONCodableScalar]? = nil, updated: Foundation.Date? = nil, eTag: Swift.String? = nil)
  public init(from other: KustomerPubSub.KustomerPubNubV3MembershipMetadata) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: KustomerPubSub.KustomerPubNubV3MembershipMetadataBase, b: KustomerPubSub.KustomerPubNubV3MembershipMetadataBase) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerPubNubV3MembershipMetadataBase : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct KustomerPubNubV3PushMessage : KustomerPubSub.JSONCodable {
  public let apns: KustomerPubSub.KustomerPubNubV3APNSPayload?
  public let fcm: KustomerPubSub.KustomerPubNubV3FCMPayload?
  public let mpns: KustomerPubSub.JSONCodable?
  public var additionalMessage: KustomerPubSub.JSONCodable?
  public init(apns: KustomerPubSub.KustomerPubNubV3APNSPayload? = nil, fcm: KustomerPubSub.KustomerPubNubV3FCMPayload? = nil, mpns: KustomerPubSub.JSONCodable? = nil, additional message: KustomerPubSub.JSONCodable? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension KustomerPubSub.KustomerPubNubV3Error.Domain : Swift.RawRepresentable {}
extension KustomerPubSub.KustomerPubNubV3Error.Reason : Swift.RawRepresentable {}
extension KustomerPubSub.CryptoError : Swift.Equatable {}
extension KustomerPubSub.CryptoError : Swift.Hashable {}
extension KustomerPubSub.CryptoError : Swift.RawRepresentable {}
extension KustomerPubSub.KUSPubSubConnectionStatus : Swift.Equatable {}
extension KustomerPubSub.KUSPubSubConnectionStatus : Swift.Hashable {}
extension KustomerPubSub.KUSPubSubConnectionStatus : Swift.RawRepresentable {}
extension KustomerPubSub.PNKeyRequirement : Swift.Equatable {}
extension KustomerPubSub.PNKeyRequirement : Swift.Hashable {}
extension KustomerPubSub.PNKeyRequirement : Swift.RawRepresentable {}
extension KustomerPubSub.PAMVersionRequirement : Swift.Equatable {}
extension KustomerPubSub.PAMVersionRequirement : Swift.Hashable {}
extension KustomerPubSub.HTTPMethod : Swift.Equatable {}
extension KustomerPubSub.HTTPMethod : Swift.Hashable {}
extension KustomerPubSub.HTTPMethod : Swift.RawRepresentable {}
extension KustomerPubSub.KustomerPubNubV3Service : Swift.Equatable {}
extension KustomerPubSub.KustomerPubNubV3Service : Swift.Hashable {}
extension KustomerPubSub.KustomerPubNubV3Service : Swift.RawRepresentable {}
extension KustomerPubSub.KustomerPubNubV3.PushEnvironment : Swift.Equatable {}
extension KustomerPubSub.KustomerPubNubV3.PushEnvironment : Swift.Hashable {}
extension KustomerPubSub.KustomerPubNubV3.PushEnvironment : Swift.RawRepresentable {}
extension KustomerPubSub.KustomerPubNubV3.PushService : Swift.Equatable {}
extension KustomerPubSub.KustomerPubNubV3.PushService : Swift.Hashable {}
extension KustomerPubSub.KustomerPubNubV3.PushService : Swift.RawRepresentable {}
extension KustomerPubSub.KustomerPubNubV3.ObjectSortProperty : Swift.Equatable {}
extension KustomerPubSub.KustomerPubNubV3.ObjectSortProperty : Swift.Hashable {}
extension KustomerPubSub.KustomerPubNubV3.ObjectSortProperty : Swift.RawRepresentable {}
extension KustomerPubSub.FCMWebpushDirection : Swift.RawRepresentable {}
extension KustomerPubSub.FCMAndroidMessagePriority : Swift.RawRepresentable {}
extension KustomerPubSub.FCMAndroidVisibility : Swift.RawRepresentable {}
extension KustomerPubSub.FCMAndroidNotificationPriority : Swift.RawRepresentable {}
extension KustomerPubSub.PAMTokenManagementSystem.Resource : Swift.Equatable {}
extension KustomerPubSub.PAMTokenManagementSystem.Resource : Swift.Hashable {}
extension KustomerPubSub.URLConvertibleError : Swift.Equatable {}
extension KustomerPubSub.URLConvertibleError : Swift.Hashable {}
